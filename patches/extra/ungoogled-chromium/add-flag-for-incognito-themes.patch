--- a/chrome/browser/ungoogled_flag_entries.h
+++ b/chrome/browser/ungoogled_flag_entries.h
@@ -100,4 +100,8 @@
      "Custom HTTP Accept Header",
      "Set a custom value for the Accept header which is sent by the browser with every HTTP request.  (e.g. `text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8`).  ungoogled-chromium flag.",
      kOsAll, ORIGIN_LIST_VALUE_TYPE("http-accept-header", "")},
+    {"enable-incognito-themes",
+     "Enable themes in Incognito mode",
+     "Allows themes to override Google's built-in Incognito theming.  ungoogled-chromium flag.",
+     kOsAll, SINGLE_VALUE_TYPE("enable-incognito-themes")},
 #endif  // CHROME_BROWSER_UNGOOGLED_FLAG_ENTRIES_H_
--- a/chrome/browser/themes/theme_helper.cc
+++ b/chrome/browser/themes/theme_helper.cc
@@ -4,6 +4,7 @@

 #include "chrome/browser/themes/theme_service.h"

+#include "base/command_line.h
 #include "base/feature_list.h"
 #include "base/no_destructor.h"
 #include "build/build_config.h"
@@ -171,6 +172,32 @@ SeparatorColorCache& GetSeparatorColorCache() {
   return *cache;
 }

+// For legacy reasons, the theme supplier requires the incognito variants of
+// color IDs.  This converts from normal to incognito IDs where they exist.
+int GetIncognitoId(int id) {
+  switch (id) {
+    case TP::COLOR_FRAME_ACTIVE:
+      return TP::COLOR_FRAME_ACTIVE_INCOGNITO;
+    case TP::COLOR_FRAME_INACTIVE:
+      return TP::COLOR_FRAME_INACTIVE_INCOGNITO;
+    case TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_ACTIVE:
+      return TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_ACTIVE_INCOGNITO;
+    case TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_INACTIVE:
+      return TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_INACTIVE_INCOGNITO;
+    case TP::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_ACTIVE:
+      return TP::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_ACTIVE_INCOGNITO;
+    case TP::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_INACTIVE:
+      return TP::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_INACTIVE_INCOGNITO;
+    case TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_ACTIVE:
+      return TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_INCOGNITO_ACTIVE;
+    case TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_INACTIVE:
+      return TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_INCOGNITO_INACTIVE;
+    default:
+      return id;
+  }
+}
+
+
 }  // namespace

 const char ThemeHelper::kDefaultThemeID[] = "";
@@ -281,9 +308,11 @@ SkColor ThemeHelper::GetColor(int id,
                               const CustomThemeSupplier* theme_supplier) const {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);

-  if (theme_supplier && !incognito) {
+  if (theme_supplier &&
+        !ShouldIgnoreThemeSupplier(id, incognito, theme_supplier)) {
     SkColor color;
-    if (theme_supplier->GetColor(id, &color))
+    const int theme_supplier_id = incognito ? GetIncognitoId(id) : id;
+    if (theme_supplier->GetColor(theme_supplier_id, &color))
       return color;
   }

@@ -299,7 +328,8 @@ color_utils::HSL ThemeHelper::GetTint(
   if (theme_supplier && theme_supplier->GetTint(id, &hsl))
     return hsl;

-  return TP::GetDefaultTint(id, incognito, UseDarkModeColors(theme_supplier));
+  const bool use_incognito_tint = incognito && UseIncognitoColor(id, theme_supplier);
+  return TP::GetDefaultTint(id, use_incognito_tint, UseDarkModeColors(theme_supplier));
 }

 gfx::ImageSkia* ThemeHelper::GetImageSkiaNamed(
@@ -554,7 +584,18 @@ SkColor ThemeHelper::GetDefaultColor(
                       incognito, theme_supplier);
   }

-  return TP::GetDefaultColor(id, incognito, UseDarkModeColors(theme_supplier));
+  const bool use_incognito_color = incognito && UseIncognitoColor(id, theme_supplier);
+  return TP::GetDefaultColor(id, use_incognito_color, UseDarkModeColors(theme_supplier));
+}
+
+// static
+bool ThemeHelper::UseIncognitoColor(int id,
+                                    const CustomThemeSupplier* theme_supplier) {
+  // Incognito is disabled for any non-ignored custom theme colors so they apply
+  // atop a predictable state.
+  return ShouldIgnoreThemeSupplier(id, true, theme_supplier) ||
+         (!IsCustomTheme(theme_supplier) &&
+          (!theme_supplier || theme_supplier->CanUseIncognitoColors()));
 }

 // static
@@ -565,6 +606,20 @@ bool ThemeHelper::UseDarkModeColors(const CustomThemeSupplier* theme_supplier) {
          ui::NativeTheme::GetInstanceForNativeUi()->ShouldUseDarkColors();
 }

+// static
+bool ThemeHelper::ShouldIgnoreThemeSupplier(
+    int id,
+    bool incognito,
+    const CustomThemeSupplier* theme_supplier) {
+  if (incognito && !base::CommandLine::ForCurrentProcess()->HasSwitch("enable-incognito-themes")) {
+    return true;
+  }
+  // The incognito NTP uses the default background color instead of any theme
+  // background color, unless the theme also sets a custom background image.
+  return incognito && (id == TP::COLOR_NTP_BACKGROUND) &&
+         !HasCustomImage(IDR_THEME_NTP_BACKGROUND, theme_supplier);
+}
+
 gfx::Image ThemeHelper::GetImageNamed(
     int id,
     bool incognito,
     --- a/chrome/browser/themes/theme-helper.h
+++ b/chrome/browser/themes/theme-helper.h
@@ -110,9 +110,21 @@ class ThemeHelper {
  private:
   friend class theme_service_internal::ThemeServiceTest;

+  // Whether the default incognito color/tint for |id| should be used, if
+  // available.
+  static bool UseIncognitoColor(int id,
+                                const CustomThemeSupplier* theme_supplier);
+
   // Whether dark default colors/tints should be used, if available.
   static bool UseDarkModeColors(const CustomThemeSupplier* theme_supplier);

+  // Whether the color from |theme_supplier| (if any) should be ignored for
+  // the given |id| and |incognito| state.
+  static bool ShouldIgnoreThemeSupplier(
+      int id,
+      bool incognito,
+      const CustomThemeSupplier* theme_supplier);
+
   // Returns a cross platform image for an id.
   gfx::Image GetImageNamed(int id,
                            bool incognito,
--- a/chrome/browser/themes/theme_service.cc
+++ b/chrome/browser/themes/theme_service.cc
@@ -507,7 +507,7 @@ ThemeService::BrowserThemeProvider::GetColorProviderColor(int id) const {
     if (auto provider_color_id = ThemeProviderColorIdToColorId(id)) {
       const ui::NativeTheme* native_theme = nullptr;

-      if (incognito_) {
+      if (incognito_ && !base::CommandLine::ForCurrentProcess()->HasSwitch("enable-incognito-themes")) {
         native_theme = ui::NativeTheme::GetInstanceForDarkUI();
       } else {
         native_theme = ui::NativeTheme::GetInstanceForNativeUi();
@@ -532,7 +532,8 @@ ThemeService::BrowserThemeProvider::GetColorProviderColor(int id) const {

 CustomThemeSupplier* ThemeService::BrowserThemeProvider::GetThemeSupplier()
     const {
-  return incognito_ ? nullptr : delegate_->GetThemeSupplier();
+      const bool ignore_theme_supplier = incognito_ && !base::CommandLine::ForCurrentProcess()->HasSwitch("enable-incognito-themes");
+  return ignore_theme_supplier ? nullptr : delegate_->GetThemeSupplier();
 }

 // ThemeService ---------------------------------------------------------------
@@ -772,7 +773,9 @@ ThemeSyncableService* ThemeService::GetThemeSyncableService() const {
 const ui::ThemeProvider& ThemeService::GetThemeProviderForProfile(
     Profile* profile) {
   ThemeService* service = ThemeServiceFactory::GetForProfile(profile);
-  return profile->IsIncognitoProfile() ? service->incognito_theme_provider_
+  const bool use_incognito_provider = profile->IsIncognitoProfile() &&
+      !base::CommandLine::ForCurrentProcess()->HasSwitch("enable-incognito-themes");
+  return use_incognito_provider ? service->incognito_theme_provider_
                                        : service->original_theme_provider_;
 }

--- a/chrome/browser/ui/views/frame/browser_frame.cc
+++ b/chrome/browser/ui/views/frame/browser_frame.cc
@@ -248,8 +248,10 @@ ui::ColorProviderManager::ThemeInitializerSupplier*
 BrowserFrame::GetCustomTheme() const {
   Browser* browser = browser_view_->browser();
   // If this is an incognito profile, there should never be a custom theme.
-  if (browser->profile()->IsIncognitoProfile())
+  if (browser->profile()->IsIncognitoProfile() &&
+      !base::CommandLine::ForCurrentProcess()->HasSwitch("enable-incognito-themes")) {
     return nullptr;
+  }
   auto* app_controller = browser->app_controller();
   // Ignore GTK+ for web apps with window-controls-overlay as the
   // display_override so the web contents can blend with the overlay by using
@@ -382,7 +384,8 @@ void BrowserFrame::SelectNativeTheme() {
   // Select between regular, dark and GTK theme.
   ui::NativeTheme* native_theme = ui::NativeTheme::GetInstanceForNativeUi();

-  if (browser_view_->browser()->profile()->IsIncognitoProfile()) {
+  if (browser_view_->browser()->profile()->IsIncognitoProfile() &&
+        !base::CommandLine::ForCurrentProcess()->HasSwitch("enable-incognito-themes")) {
     // No matter if we are using the default theme or not we always use the dark
     // ui instance.
     SetNativeTheme(ui::NativeTheme::GetInstanceForDarkUI());
--- a/ui/views/widget/widget.cc
+++ b/ui/views/widget/widget.cc
@@ -10,6 +10,7 @@
 #include "base/auto_reset.h"
 #include "base/bind.h"
 #include "base/check_op.h"
+#include "base/command_line.h"
 #include "base/containers/adapters.h"
 #include "base/i18n/rtl.h"
 #include "base/notreached.h"
@@ -1818,7 +1819,7 @@ const ui::NativeTheme* Widget::GetNativeTheme() const {
   if (native_theme_)
     return native_theme_;

-  if (parent_)
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch("enable-incognito-themes") && parent_)
     return parent_->GetNativeTheme();

 #if BUILDFLAG(IS_LINUX)
